#!/usr/bin/env python
import logging
import optparse
import os
import re
import sys
import termios
import ConfigParser, os

from ConfigParser import NoSectionError, NoOptionError
from functools import partial
from logging import warn, info, debug

from yoyo.migrate.connections import connect

CONFIG_PATH = os.path.expanduser('~/.yoyo-migrate')

def readconfig():
    config = ConfigParser.ConfigParser()
    config.read([CONFIG_PATH])
    return config

def saveconfig(config):
    f = open(CONFIG_PATH, 'w')
    try:
        return config.write(f)
    finally:
        f.close()


class DatabaseError(Exception):
    pass

def getch():
    """
    Read a single character without echoing to the console and without having
    to wait for a newline.
    """
    fd = sys.stdin.fileno()
    saved_attributes = termios.tcgetattr(fd)
    try:
        attributes = termios.tcgetattr(fd) # get a fresh copy!
        attributes[3] = attributes[3] & ~(termios.ICANON | termios.ECHO)
        attributes[6][termios.VMIN] = 1
        attributes[6][termios.VTIME] = 0
        termios.tcsetattr(fd, termios.TCSANOW, attributes)

        a = sys.stdin.read(1)
    finally:
        #be sure to reset the attributes no matter what!
        termios.tcsetattr(fd, termios.TCSANOW, saved_attributes)
    return a

def prompt(prompt, options):
    """
    Display the given prompt and list of options and return the user selection.
    """

    while True:
        sys.stdout.write("%s [%s]: " % (prompt, options))
        ch = getch()
        if ch == '\n':
            ch = ([o.lower() for o in options if 'A' <= o <= 'Z'] + list(options.lower()))[0]
        print ch
        if ch.lower() not in options.lower():
            print "Invalid response, please try again!"
        else:
            break

    return ch.lower()

class prompted_migration(object):

    def __init__(self, migration, default=None):
        super(prompted_migration, self).__init__()
        self.migration = migration
        self.choice = default


def prompt_migrations(conn, migrations, direction):
    """
    Iterate through the list of migrations and prompt the user to apply/rollback each.
    Return a list of user selected migrations.

    direction
        one of 'apply' or 'rollback'
    """
    migrations = [ prompted_migration(m) for m in migrations ]

    position = 0
    while position < len(migrations):
        mig = migrations[position]

        choice = mig.choice
        if choice is None:
            if direction == 'apply':
                choice = 'n' if mig.migration.isapplied(conn) else 'y'
            else:
                choice = 'y' if mig.migration.isapplied(conn) else 'n'
        options = ''.join(o.upper() if o == choice else o.lower() for o in 'ynvdaqjk?')

        print ""
        print '[%s]' % (mig.migration.id,)
        response = prompt("Shall I %s this migration?" % (direction,), options)

        if response == '?':
            print ""
            print "y: %s this migration" % (direction,)
            print "n: don't %s it" % (direction,)
            print ""
            print "v: view this migration in full"
            print ""
            print "d: %s the selected migrations, skipping any remaining" % (direction,)
            print "a: %s all the remaining migrations" % (direction,)
            print "q: cancel without making any changes"
            print ""
            print "j: skip to next migration"
            print "k: back up to previous migration"
            print ""
            print "?: show this help"
            continue

        if response in 'yn':
            mig.choice = response
            position += 1
            continue

        if response == 'v':
            print mig.migration.source
            continue

        if response == 'j':
            position = min(len(migrations), position + 1)
            continue

        if response == 'k':
            position = max(0, position - 1)

        if response == 'd':
            break

        if response == 'a':
            for mig in migrations[position:]:
                mig.choice = 'y'
            break

        if response == 'q':
            for mig in migrations:
                mig.choice = 'n'
            break


    return [m.migration for m in migrations if m.choice == 'y']


class Migration(object):

    def __init__(self, id, steps, source):
        self.id = id
        self.steps = steps
        self.source = source

    def isapplied(self, conn):
        cursor = conn.cursor()
        try:
            cursor.execute(
                "SELECT COUNT(1) FROM migration WHERE id=%s",
                (self.id,)
            )
            return cursor.fetchone()[0] > 0
        finally:
            cursor.close()

    def migrate(self, conn, force=False):
        info("Applying %s", self.id)
        Migration._process_steps(self.steps, conn, 'apply', force=force)
        cursor = conn.cursor()
        cursor.execute("INSERT INTO migration (id) VALUES (%s)", (self.id,))
        conn.commit()
        cursor.close()

    def rollback(self, conn, force=False):
        info("Rolling back %s", self.id)
        Migration._process_steps(reversed(self.steps), conn, 'rollback', force=force)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM migration WHERE id=%s", (self.id,))
        conn.commit()
        cursor.close()

    @staticmethod
    def _process_steps(steps, conn, direction, force=False):

        reverse = {
            'rollback': 'apply',
            'apply': 'rollback',
        }[direction]

        executed_steps = []
        for ix, step in enumerate(steps):
            try:
                if getattr(step, direction)(conn, force):
                    executed_steps.append(step)
            except DatabaseError:
                conn.rollback()
                exc_info = sys.exc_info()
                try:
                    for step in reversed(executed_steps):
                        getattr(step, reverse)(conn)
                except DatabaseError:
                    logging.exception('Database error when reversing %s  of step', direction)
                raise exc_info[0], exc_info[1], exc_info[2]


class MigrationStep(object):
    """
    Model a single migration. Each migration step comprises a single apply and
    rollback step of up and down SQL statements.
    """
    def __init__(self, id, apply, rollback, ignore_errors):

        assert ignore_errors in (None, 'all', 'apply', 'rollback')

        self.id = id
        self._rollback = rollback
        self._apply = apply
        self.ignore_errors = ignore_errors

    def _execute(self, cursor, stmt):
        if isinstance(stmt, unicode):
            debug(" - executing %r", stmt.encode('ascii', 'replace'))
        else:
            debug(" - executing %r", stmt)
        return cursor.execute(stmt)


    def apply(self, conn, force=False):
        """
        Apply the step and commit the change. Return ``True`` if a change was
        successfully applied, ``False`` if there was no apply action for this
        step.
        """
        info(" - applying step %d", self.id)
        if self._apply is None:
            return False
        cursor = conn.cursor()
        try:
            try:
                if callable(self._apply):
                    self._apply(cursor)
                else:
                    self._execute(cursor, self._apply)
                conn.commit()
            except DatabaseError:
                if force or self.ignore_errors in ('apply', 'all'):
                    conn.rollback()
                    logging.exception("Ignored error in step %d", self.id)
                else:
                    raise
        finally:
            cursor.close()
        return True

    def rollback(self, conn, force=False):
        """
        Rollback the step and commit the change. Return ``True`` if a change
        was successfully rolled back, ``False`` if there was no rollback action
        for this step.
        """
        info(" - rolling back step %d", self.id)
        if self._rollback is None:
            return
        cursor = conn.cursor()
        try:
            try:
                if callable(self._rollback):
                    self._rollback(cursor)
                else:
                    self._execute(cursor, self._rollback)
                conn.commit()
            except DatabaseError:
                if force or self.ignore_errors in ('rollback', 'all'):
                    logging.exception("Ignoring error in step %d", self.id)
                    conn.rollback()
                else:
                    raise
        finally:
            cursor.close()


def read_migrations(directory, names=None):
    """
    Yield migrations from ``directory``, optionally limiting to those with the
    specified filenames (without extensions).
    """

    paths = [
        os.path.join(migrations_dir, path) for path in os.listdir(migrations_dir) if path.endswith('.py')
    ]

    for path in sorted(paths):

        filename = os.path.splitext(os.path.basename(path))[0]
        if names is not None and filename not in names:
            continue

        steps = []
        def step(apply, rollback=None, ignore_errors=None):
            steps.append(MigrationStep(len(steps), apply, rollback, ignore_errors))

        file = open(path, 'r')
        try:
            source = file.read()
            migration = compile(source, file.name, 'exec')
        finally:
            file.close()
        ns = { 'step' : step }
        exec migration in ns
        yield Migration(os.path.basename(filename), steps, source)

def create_migrations_table(conn):
    try:
        cursor = conn.cursor()
        try:
            try:
                cursor.execute("""
                    CREATE TABLE migration (id VARCHAR(255) NOT NULL PRIMARY KEY, ctime TIMESTAMP DEFAULT NOW())
                """)
                conn.commit()
            except DatabaseError:
                pass
        finally:
            cursor.close()
    finally:
        conn.rollback()


if __name__ == "__main__":

    config = readconfig()
    optparser = optparse.OptionParser(usage="%prog apply|rollback <database> <migrations>")
    optparser.add_option(
        "-m", "--match", dest="match",
        help="Select migrations matching PATTERN (perl-compatible regular expression)", metavar='PATTERN',
    )
    optparser.add_option(
        "-a", "--all", dest="all", action="store_true",
        help="Select all migrations, regardless of whether they have been previously applied"
    )
    optparser.add_option(
        "-b", "--batch", dest="batch", action="store_true",
        help="Run in batch mode (don't ask before applying/rolling back each migration)"
    )
    optparser.add_option(
        "-v", "--verbosity", dest="verbosity", default="0",
        help="Set verbosity (0-3). default is no output"
    )
    optparser.add_option(
        "", "--force", dest="force", action="store_true",
        help="Force apply/rollback of steps even if previous steps have failed"
    )


    opts, args = optparser.parse_args()

    try:
        logging.getLogger().setLevel(
            {
                0: logging.ERROR, 1: logging.WARN,
                2: logging.INFO, 3: logging.DEBUG
            }[int(opts.verbosity)]
        )
    except KeyError:
        optparser.error("Invalid verbosity level")
        sys.exit(1)


    command = dburi = migrations_dir = None
    try:
        command, dburi, migrations_dir = args
        migrations_dir = os.path.normpath(os.path.abspath(migrations_dir))
    except ValueError:
        try:
            command, migrations_dir = args
            migrations_dir = os.path.normpath(os.path.abspath(migrations_dir))
            logging.debug("Looking up dburi for %r", migrations_dir)
            dburi = config.get(migrations_dir, 'dburi')
        except (ValueError, NoSectionError, NoOptionError):
            pass

    if dburi is None:
        optparser.error(
            "Please specify a command, "
            "database connection string "
            "and path to the migrations directory"
        )
        sys.exit(1)

    # Store the database this directory is being applied to so that subsequent
    # runs don't need the dburi argument
    if not config.has_section(migrations_dir):
        config.add_section(migrations_dir)
    if not config.has_option(migrations_dir, 'dburi') or config.get(migrations_dir, 'dburi') != dburi:
        config.set(migrations_dir, 'dburi', dburi)
        saveconfig(config)

    if command not in ['apply', 'rollback']:
        optparser.error("Invalid command")
        sys.exit(1)

    conn, module = connect(dburi)
    getattr(module, 'DatabaseError').__bases__ += (DatabaseError,)

    create_migrations_table(conn)

    migrations = list(read_migrations(migrations_dir))
    if opts.match:
        migrations = [ m for m in migrations if re.search(opts.match, m.id) is not None ]

    if not opts.all:
        if command == 'apply':
            test = lambda m: not m.isapplied(conn)
        else:
            test = lambda m: m.isapplied(conn)
        migrations = [ m for m in migrations if test(m) ]

    if command == 'rollback':
        migrations = reversed(migrations)

    if not opts.batch:
        migrations = prompt_migrations(conn, migrations, command)

    for migration in migrations:
        if command == 'apply':
            migration.migrate(conn, opts.force)
        else:
            migration.rollback(conn, opts.force)

