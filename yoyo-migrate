#!/usr/bin/env python
import logging
import optparse
import os
import re
import sys
import termios
import ConfigParser, os

from ConfigParser import NoSectionError, NoOptionError
from functools import partial
from logging import debug

from yoyo.migrate.connections import connect
from yoyo.migrate.utils import prompt, plural
from yoyo.migrate import Migration, MigrationStep
from yoyo.migrate import DatabaseError
from yoyo.migrate import read_migrations, create_migrations_table

CONFIG_PATH = os.path.expanduser('~/.yoyo-migrate')

def readconfig():
    config = ConfigParser.ConfigParser()
    config.read([CONFIG_PATH])
    return config

def saveconfig(config):
    f = open(CONFIG_PATH, 'w')
    try:
        return config.write(f)
    finally:
        f.close()

class prompted_migration(object):

    def __init__(self, migration, default=None):
        super(prompted_migration, self).__init__()
        self.migration = migration
        self.choice = default


def prompt_migrations(conn, migrations, direction):
    """
    Iterate through the list of migrations and prompt the user to apply/rollback each.
    Return a list of user selected migrations.

    direction
        one of 'apply' or 'rollback'
    """
    migrations = migrations.replace(prompted_migration(m) for m in migrations)

    position = 0
    while position < len(migrations):
        mig = migrations[position]

        choice = mig.choice
        if choice is None:
            if direction == 'apply':
                choice = 'n' if mig.migration.isapplied(conn) else 'y'
            else:
                choice = 'y' if mig.migration.isapplied(conn) else 'n'
        options = ''.join(o.upper() if o == choice else o.lower() for o in 'ynvdaqjk?')

        print ""
        print '[%s]' % (mig.migration.id,)
        response = prompt("Shall I %s this migration?" % (direction,), options)

        if response == '?':
            print ""
            print "y: %s this migration" % (direction,)
            print "n: don't %s it" % (direction,)
            print ""
            print "v: view this migration in full"
            print ""
            print "d: %s the selected migrations, skipping any remaining" % (direction,)
            print "a: %s all the remaining migrations" % (direction,)
            print "q: cancel without making any changes"
            print ""
            print "j: skip to next migration"
            print "k: back up to previous migration"
            print ""
            print "?: show this help"
            continue

        if response in 'yn':
            mig.choice = response
            position += 1
            continue

        if response == 'v':
            print mig.migration.source
            continue

        if response == 'j':
            position = min(len(migrations), position + 1)
            continue

        if response == 'k':
            position = max(0, position - 1)

        if response == 'd':
            break

        if response == 'a':
            for mig in migrations[position:]:
                mig.choice = 'y'
            break

        if response == 'q':
            for mig in migrations:
                mig.choice = 'n'
            break

    return migrations.filter(lambda m: m.choice == 'y')

if __name__ == "__main__":

    config = readconfig()
    optparser = optparse.OptionParser(usage="%prog apply|rollback <database> <migrations>")
    optparser.add_option(
        "-m", "--match", dest="match",
        help="Select migrations matching PATTERN (perl-compatible regular expression)", metavar='PATTERN',
    )
    optparser.add_option(
        "-a", "--all", dest="all", action="store_true",
        help="Select all migrations, regardless of whether they have been previously applied"
    )
    optparser.add_option(
        "-b", "--batch", dest="batch", action="store_true",
        help="Run in batch mode (don't ask before applying/rolling back each migration)"
    )
    optparser.add_option(
        "-v", "--verbosity", dest="verbosity", default="0",
        help="Set verbosity (0-3). default is no output"
    )
    optparser.add_option(
        "", "--force", dest="force", action="store_true",
        help="Force apply/rollback of steps even if previous steps have failed"
    )


    opts, args = optparser.parse_args()

    try:
        logging.getLogger().setLevel(
            {
                0: logging.ERROR, 1: logging.WARN,
                2: logging.INFO, 3: logging.DEBUG
            }[int(opts.verbosity)]
        )
    except KeyError:
        optparser.error("Invalid verbosity level")
        sys.exit(1)


    command = dburi = migrations_dir = None
    try:
        command, dburi, migrations_dir = args
        migrations_dir = os.path.normpath(os.path.abspath(migrations_dir))
    except ValueError:
        try:
            command, migrations_dir = args
            migrations_dir = os.path.normpath(os.path.abspath(migrations_dir))
            debug("Looking up dburi for %r", migrations_dir)
            dburi = config.get(migrations_dir, 'dburi')
        except (ValueError, NoSectionError, NoOptionError):
            pass

    if dburi is None:
        optparser.error(
            "Please specify a command, "
            "database connection string "
            "and path to the migrations directory"
        )
        sys.exit(1)

    # Store the database this directory is being applied to so that subsequent
    # runs don't need the dburi argument
    if not config.has_section(migrations_dir):
        config.add_section(migrations_dir)
    if not config.has_option(migrations_dir, 'dburi') or config.get(migrations_dir, 'dburi') != dburi:
        config.set(migrations_dir, 'dburi', dburi)
        saveconfig(config)

    if command not in ['apply', 'rollback', 'reapply']:
        optparser.error("Invalid command")
        sys.exit(1)

    conn, module = connect(dburi)
    getattr(module, 'DatabaseError').__bases__ += (DatabaseError,)

    create_migrations_table(conn)

    migrations = read_migrations(conn, migrations_dir)

    if opts.match:
        migrations = migrations.filter(lambda m: re.search(opts.match, m.id) is not None)

    if command in ['reapply', 'rollback']:
        migrations = reversed(migrations)

    if not opts.all:
        if command in ['apply']:
            migrations = migrations.to_apply()

        elif command in ['reapply', 'rollback']:
            migrations = migrations.to_rollback()

    if not opts.batch:
        migrations = prompt_migrations(conn, migrations, command)

    if not opts.batch and migrations:
        if prompt(command.title() + plural(len(migrations), " %d migration", " %d migrations") + " to %s?" % dburi, "Yn") != 'y':
            sys.exit(0)

    if command == 'reapply':
        migrations.rollback(opts.force)
        migrations.apply(opts.force)

    elif command == 'apply':
        migrations.apply(opts.force)

    elif command == 'rollback':
        migrations.rollback(opts.force)

