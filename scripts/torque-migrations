#!/usr/bin/env python
import compiler
import logging
import optparse
import os
import sys

from storm.database import create_database
from storm.store import Store
from storm.exceptions import DatabaseError
from functools import partial

VERBOSITY = 0

class Migration(object):

    def __init__(self, id, steps):
        self.id = id
        self.steps = steps

    def isapplied(self, store):
        return store.execute(
            "SELECT COUNT(1) FROM migration WHERE id=%s",
            (self.id,)
        ).get_one()[0] > 0

    def migrate(self, store, force=False):

        if VERBOSITY >= 2 and self.isapplied(store):
            print "Migration %r already applied" % (self.id,)

        if force or not self.isapplied(store):
            if VERBOSITY >= 1:
                print "Applying", self.id
            for ix, step in enumerate(self.steps):
                try:
                    step.apply(store)
                    store.commit()
                except DatabaseError:
                    for step in reversed(self.steps[:ix]):
                        step.rollback(store)
                        store.commit()
                    raise
            try:
                store.execute("INSERT INTO migration VALUES (%s, now())", (self.id,))
            except DatabaseError:
                store.rollback()
            store.commit()

    def rollback(self, store, force=False):
        if force or self.isapplied(store):
            if VERBOSITY >= 1:
                print "rolling back", self.id
            for step in reversed(self.steps):
                try:
                    step.rollback(store)
                    store.commit()
                except DatabaseError:
                    step.apply(store)
                    store.commit()
                    raise
            try:
                store.execute("DELETE FROM migration WHERE id=%s", (self.id,))
            except DatabaseError:
                store.rollback()
            store.commit()


class MigrationStep(object):
    """
    Model a single migration. Each migration step comprises a single apply and rollback step
    of up and down SQL statements.
    """
    def __init__(self, id, apply, rollback):
        self.id = id
        self._rollback = rollback
        self._apply = apply

    def _execute(self, store, stmt):
        if VERBOSITY >= 3:
            print " - executing", stmt
        return store.execute(stmt)


    def apply(self, store):
        if VERBOSITY >= 2:
            print " - applying step", self.id
        if callable(self._apply):
            self._apply(store)
        else:
            self._execute(store, self._apply)

    def rollback(self, store):
        if VERBOSITY >= 2:
            print " - rolling back step", self.id
        if self._rollback is None:
            return
        if callable(self._rollback):
            self._rollback(store)
        else:
            self._execute(store, self._rollback)


def read_migrations(directory, names=None):
    """
    Yield migrations from ``directory``, optionally limiting to those with the
    specified filenames (without extensions).
    """

    paths = [ 
        os.path.join(migrations_dir, path) for path in os.listdir(migrations_dir) if path.endswith('.py')
    ]

    for path in sorted(paths):

        filename = os.path.splitext(os.path.basename(path))[0]
        if names is not None and filename not in names:
            continue

        file = open(path, 'r')

        steps = []
        def step(apply, rollback=None):
            steps.append(MigrationStep(len(steps), apply, rollback))

        try:
            migration = compiler.compile(file.read(), file.name, 'exec')
            ns = { 'step' : step }
            exec migration in ns
            yield Migration(filename, steps)
        finally:
            file.close()

if __name__ == "__main__":

    optparser = optparse.OptionParser()
    optparser.add_option(
        "--apply", dest="apply_migrations",
        help="Apply specified migrations (separate multiple names with commas)",
    )
    optparser.add_option(
        "--rollback", dest="rollback_migrations",
        help="Rollback specified migrations (separate multiple names with commas)",
    )
    optparser.add_option(
        "-a", "--all", dest="all", action="store_true",
        help="Run all applicable upward migrations"
    )
    optparser.add_option(
        "-f", "--force", dest="force", action="store_true",
        help="Force rerun even if migration appears previously applied"
    )
    optparser.add_option(
        "-v", "--verbosity", dest="verbosity", default="0",
        help="Set verbosity (0-3). default is no output"
    )
    opts, args = optparser.parse_args()

    dburi, migrations_dir = args

    store = Store(create_database(dburi))
    try:
        try:
            store.execute("""
                CREATE TABLE migration (id VARCHAR(255) NOT NULL PRIMARY KEY, ctime TIMESTAMP DEFAULT NOW())
            """)
            store.commit()
        except DatabaseError:
            pass
    finally:
        store.rollback()

    VERBOSITY = int(opts.verbosity)

    if opts.apply_migrations:
        for migration in read_migrations(migrations_dir, opts.apply_migrations.split(',')):
            migration.migrate(store, opts.force)

    elif opts.rollback_migrations:
        for migration in read_migrations(migrations_dir, opts.rollback_migrations.split(',')):
            migration.rollback(store, opts.force)

    elif opts.all:
        for migration in read_migrations(migrations_dir):
            migration.migrate(store, opts.force)

    else:
        print >> sys.stderr, "No migrations specified."
        sys.exit(1)


