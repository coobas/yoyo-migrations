#!/usr/bin/env python
import compiler
import logging
import optparse
import os
import re
import sys
import termios

from storm.database import create_database
from storm.store import Store
from storm.exceptions import DatabaseError
from functools import partial

VERBOSITY = 0

def getch():
    """
    Read a single character without echoing to the console and without having
    to wait for a newline.
    """
    fd = sys.stdin.fileno()
    saved_attributes = termios.tcgetattr(fd)
    try:
        attributes = termios.tcgetattr(fd) # get a fresh copy!
        attributes[3] = attributes[3] & ~(termios.ICANON | termios.ECHO)
        attributes[6][termios.VMIN] = 1
        attributes[6][termios.VTIME] = 0
        termios.tcsetattr(fd, termios.TCSANOW, attributes)

        a = sys.stdin.read(1)
    finally:
        #be sure to reset the attributes no matter what!
        termios.tcsetattr(fd, termios.TCSANOW, saved_attributes)
    return a

def prompt(prompt, options):
    """
    Display the given prompt and list of options and return the user selection.
    """

    while True:
        sys.stdout.write("%s [%s]: " % (prompt, options))
        ch = getch()
        if ch == '\n':
            ch = ([o.lower() for o in options if 'A' <= o <= 'Z'] + list(options.lower()))[0]
        print ch
        if ch.lower() not in options.lower():
            print "Invalid response, please try again!"
        else:
            break

    return ch.lower()

class prompted_migration(object):

    def __init__(self, migration, default=None):
        super(prompted_migration, self).__init__()
        self.migration = migration
        self.choice = default


def prompt_migrations(store, migrations, direction):
    """
    Iterate through the list of migrations and prompt the user to apply/rollback each.
    Return a list of user selected migrations.

    direction
        one of 'apply' or 'rollback'
    """
    migrations = [ prompted_migration(m) for m in migrations ]

    position = 0
    while position < len(migrations):
        mig = migrations[position]

        choice = mig.choice
        if choice is None:
            if direction == 'apply':
                choice = 'n' if mig.migration.isapplied(store) else 'y'
            else:
                choice = 'y' if mig.migration.isapplied(store) else 'n'
        options = ''.join(o.upper() if o == choice else o.lower() for o in 'ynvdaqjk?')

        print ""
        print '[%s]' % (mig.migration.id,)
        response = prompt("Shall I %s this migration?" % (direction,), options)

        if response == '?':
            print ""
            print "y: %s this migration" % (direction,)
            print "n: don't %s it" % (direction,)
            print ""
            print "v: view this migration in full"
            print ""
            print "d: %s the selected migrations, skipping any remaining" % (direction,)
            print "a: %s all the remaining migrations" % (direction,)
            print "q: cancel without making any changes"
            print ""
            print "j: skip to next migration"
            print "k: back up to previous migration"
            print ""
            print "?: show this help"
            continue

        if response in 'yn':
            mig.choice = response
            position += 1
            continue

        if response == 'v':
            print mig.migration.source
            continue

        if response == 'j':
            position = min(len(migrations), position + 1)
            continue

        if response == 'k':
            position = max(0, position - 1)

        if response == 'd':
            break

        if response == 'a':
            for mig in migrations[position:]:
                mig.choice = 'y'
            break

        if response == 'q':
            for mig in migrations:
                mig.choice = 'n'
            break


    return [m.migration for m in migrations if m.choice == 'y']


class Migration(object):

    def __init__(self, id, steps, source):
        self.id = id
        self.steps = steps
        self.source = source

    def isapplied(self, store):
        return store.execute(
            "SELECT COUNT(1) FROM migration WHERE id=%s",
            (self.id,)
        ).get_one()[0] > 0

    def migrate(self, store):

        if VERBOSITY >= 2 and self.isapplied(store):
            print "Migration %r already applied" % (self.id,)

        if VERBOSITY >= 1:
            print "Applying", self.id

        for ix, step in enumerate(self.steps):
            if VERBOSITY >= 3:
                print " - step %d: %r" % (ix, step)
            try:
                step.apply(store)
                store.commit()
            except DatabaseError:
                exc_info = sys.exc_info()
                try:
                    for step in reversed(self.steps[:ix]):
                        step.rollback(store)
                        store.commit()
                except DatabaseError:
                    logging.exception('Database error when rolling back step')
                raise exc_info[0], exc_info[1], exc_info[2]
        try:
            store.execute("INSERT INTO migration VALUES (%s, now())", (self.id,))
        except DatabaseError:
            store.rollback()
        store.commit()

    def rollback(self, store):
        if VERBOSITY >= 1:
            print "rolling back", self.id
        steps = reversed(self.steps)
        for ix, step in enumerate(steps):
            try:
                step.rollback(store)
                store.commit()
            except DatabaseError:
                exc_info = sys.exc_info()
                try:
                    for step in reversed(list(steps)[:ix]):
                        step.apply(store)
                        store.commit()
                except DatabaseError:
                    logging.exception('Database error when re-applying step')
                raise exc_info[0], exc_info[1], exc_info[2]
        try:
            store.execute("DELETE FROM migration WHERE id=%s", (self.id,))
        except DatabaseError:
            store.rollback()
        store.commit()


class MigrationStep(object):
    """
    Model a single migration. Each migration step comprises a single apply and rollback step
    of up and down SQL statements.
    """
    def __init__(self, id, apply, rollback, ignore_errors):
        self.id = id
        self._rollback = rollback
        self._apply = apply
        self.ignore_errors = ignore_errors

    def _execute(self, store, stmt):
        if VERBOSITY >= 3:
            if isinstance(stmt, unicode):
                print " - executing", stmt.encode('ascii', 'replace')
            else:
                print " - executing", stmt
        return store.execute(stmt)


    def apply(self, store):
        if VERBOSITY >= 2:
            print " - applying step", self.id
        if self._apply is None:
            return
        try:
            if callable(self._apply):
                self._apply(store)
            else:
                self._execute(store, self._apply)
        except DatabaseError:
            if self.ignore_errors:
                logging.exception("Ignoring error in step %d", self.id)
            else:
                raise

    def rollback(self, store):
        if VERBOSITY >= 2:
            print " - rolling back step", self.id
        if self._rollback is None:
            return
        try:
            if callable(self._rollback):
                self._rollback(store)
            else:
                self._execute(store, self._rollback)
        except DatabaseError:
            if self.ignore_errors:
                logging.exception("Ignoring error in step %d", self.id)
            else:
                raise


def read_migrations(directory, names=None):
    """
    Yield migrations from ``directory``, optionally limiting to those with the
    specified filenames (without extensions).
    """

    paths = [
        os.path.join(migrations_dir, path) for path in os.listdir(migrations_dir) if path.endswith('.py')
    ]

    for path in sorted(paths):

        filename = os.path.splitext(os.path.basename(path))[0]
        if names is not None and filename not in names:
            continue

        steps = []
        def step(apply, rollback=None, ignore_errors=False):
            steps.append(MigrationStep(len(steps), apply, rollback, ignore_errors))

        file = open(path, 'r')
        try:
            source = file.read()
        finally:
            file.close()
        migration = compiler.compile(source, file.name, 'exec')
        ns = { 'step' : step }
        exec migration in ns
        yield Migration(filename, steps, source)

if __name__ == "__main__":

    optparser = optparse.OptionParser(usage="%prog apply|rollback <database> <migrations>")
    optparser.add_option(
        "-m", "--match", dest="match",
        help="Select migrations matching PATTERN (perl-compatible regular expression)", metavar='PATTERN',
    )
    optparser.add_option(
        "-a", "--all", dest="all", action="store_true",
        help="Select all migrations, regardless of whether they have been previously applied"
    )
    optparser.add_option(
        "-b", "--batch", dest="batch", action="store_true",
        help="Run in batch mode (don't ask before applying/rolling back each migration)"
    )
    optparser.add_option(
        "-v", "--verbosity", dest="verbosity", default="0",
        help="Set verbosity (0-3). default is no output"
    )

    opts, args = optparser.parse_args()
    try:
        command, dburi, migrations_dir = args
    except ValueError:
        optparser.error(
            "Please specify a command, "
            "database connection string "
            "and path to the migrations directory"
        )
        sys.exit(1)

    if command not in ['apply', 'rollback']:
        optparser.error("Invalid command")
        sys.exit(1)

    store = Store(create_database(dburi))
    try:
        try:
            store.execute("""
                CREATE TABLE migration (id VARCHAR(255) NOT NULL PRIMARY KEY, ctime TIMESTAMP DEFAULT NOW())
            """)
            store.commit()
        except DatabaseError:
            pass
    finally:
        store.rollback()

    VERBOSITY = int(opts.verbosity)

    migrations = list(read_migrations(migrations_dir))
    if opts.match:
        migrations = [ m for m in migrations if re.search(opts.match, m.id) is not None ]

    if not opts.all:
        if command == 'apply':
            test = lambda m: not m.isapplied(store)
        else:
            test = lambda m: m.isapplied(store)
        migrations = [ m for m in migrations if test(m) ]

    if command == 'rollback':
        migrations = reversed(migrations)

    if not opts.batch:
        migrations = prompt_migrations(store, migrations, command)

    for migration in migrations:
        if command == 'apply':
            migration.migrate(store)
        else:
            migration.rollback(store)

